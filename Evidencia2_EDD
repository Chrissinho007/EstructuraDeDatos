{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import json\n",
    "import os\n",
    "import csv\n",
    "from dataclasses import dataclass, asdict\n",
    "from datetime import date, datetime, timedelta\n",
    "from typing import Dict, List, Optional\n",
    "\n",
    "# Archivo de persistencia\n",
    "DATA_FILE = \"data_coworking.json\"\n",
    "\n",
    "TURNOS = {\n",
    "    \"M\": \"Matutino\",\n",
    "    \"V\": \"Vespertino\",\n",
    "    \"N\": \"Nocturno\",\n",
    "}\n",
    "\n",
    "# -----------------------------\n",
    "# Modelos de datos\n",
    "# -----------------------------\n",
    "\n",
    "@dataclass\n",
    "class Cliente:\n",
    "    id: str\n",
    "    nombres: str\n",
    "    apellidos: str\n",
    "\n",
    "@dataclass\n",
    "class Sala:\n",
    "    id: str\n",
    "    nombre: str\n",
    "    cupo: int\n",
    "\n",
    "@dataclass\n",
    "class Reservacion:\n",
    "    folio: str\n",
    "    evento: str\n",
    "    id_cliente: str\n",
    "    id_sala: str\n",
    "    fecha: str\n",
    "    turno: str\n",
    "\n",
    "# -----------------------------\n",
    "# Capa de datos y persistencia\n",
    "# -----------------------------\n",
    "\n",
    "class Repositorio:\n",
    "    def _init_(self, data_file: str = DATA_FILE) -> None:\n",
    "        self.data_file = data_file\n",
    "        self.clientes: Dict[str, Cliente] = {}\n",
    "        self.salas: Dict[str, Sala] = {}\n",
    "        self.reservas: Dict[str, Reservacion] = {}\n",
    "        self._contadores = {\"C\": 0, \"S\": 0, \"R\": 0}\n",
    "        self._cargar()\n",
    "\n",
    "    def _nuevo_id(self, prefijo: str) -> str:\n",
    "        self._contadores[prefijo] += 1\n",
    "        return f\"{prefijo}{self._contadores[prefijo]:04d}\"\n",
    "\n",
    "    def _cargar(self) -> None:\n",
    "        if not os.path.exists(self.data_file):\n",
    "            print(\"\\n>>> No se encontró una versión anterior del estado.\")\n",
    "            print(\">>> Se inicia con un estado inicial vacío.\\n\")\n",
    "            self._guardar()\n",
    "            return\n",
    "        \n",
    "        try:\n",
    "            with open(self.data_file, \"r\", encoding=\"utf-8\") as f:\n",
    "                data = json.load(f)\n",
    "            print(\"\\n>>> Se encontró una versión anterior del estado.\")\n",
    "            print(\">>> Estado recuperado exitosamente.\\n\")\n",
    "        except Exception as e:\n",
    "            print(f\"\\n>>> Error al cargar archivo: {e}\")\n",
    "            print(\">>> Se inicia con un estado inicial vacío.\\n\")\n",
    "            self._guardar()\n",
    "            return\n",
    "\n",
    "        for c in data.get(\"clientes\", []):\n",
    "            self.clientes[c[\"id\"]] = Cliente(**c)\n",
    "        for s in data.get(\"salas\", []):\n",
    "            self.salas[s[\"id\"]] = Sala(**s)\n",
    "        for r in data.get(\"reservas\", []):\n",
    "            self.reservas[r[\"folio\"]] = Reservacion(**r)\n",
    "        self._contadores = data.get(\"contadores\", {\"C\": 0, \"S\": 0, \"R\": 0})\n",
    "\n",
    "    def _guardar(self) -> None:\n",
    "        data = {\n",
    "            \"clientes\": [asdict(c) for c in self.clientes.values()],\n",
    "            \"salas\": [asdict(s) for s in self.salas.values()],\n",
    "            \"reservas\": [asdict(r) for r in self.reservas.values()],\n",
    "            \"contadores\": self._contadores,\n",
    "        }\n",
    "        with open(self.data_file, \"w\", encoding=\"utf-8\") as f:\n",
    "            json.dump(data, f, ensure_ascii=False, indent=2)\n",
    "\n",
    "    # -----------------------------\n",
    "    # Gestión de clientes\n",
    "    # -----------------------------\n",
    "\n",
    "    def registrar_cliente(self, nombres: str, apellidos: str) -> Cliente:\n",
    "        nombres = nombres.strip()\n",
    "        apellidos = apellidos.strip()\n",
    "        if not nombres or not apellidos:\n",
    "            raise ValueError(\"Nombres y apellidos no pueden estar vacíos.\")\n",
    "\n",
    "        for c in self.clientes.values():\n",
    "            if c.nombres.lower() == nombres.lower() and c.apellidos.lower() == apellidos.lower():\n",
    "                raise ValueError(\"El cliente ya existe.\")\n",
    "\n",
    "        cid = self._nuevo_id(\"C\")\n",
    "        cliente = Cliente(id=cid, nombres=nombres, apellidos=apellidos)\n",
    "        self.clientes[cid] = cliente\n",
    "        self._guardar()\n",
    "        return cliente\n",
    "\n",
    "    def listar_clientes_ordenados(self) -> List[Cliente]:\n",
    "        return sorted(self.clientes.values(), key=lambda c: (c.apellidos.lower(), c.nombres.lower()))\n",
    "\n",
    "    # -----------------------------\n",
    "    # Gestión de salas\n",
    "    # -----------------------------\n",
    "\n",
    "    def registrar_sala(self, nombre: str, cupo: int) -> Sala:\n",
    "        nombre = nombre.strip()\n",
    "        if not nombre:\n",
    "            raise ValueError(\"El nombre de la sala no puede estar vacío.\")\n",
    "        if cupo <= 0:\n",
    "            raise ValueError(\"El cupo debe ser mayor que 0.\")\n",
    "        for s in self.salas.values():\n",
    "            if s.nombre.lower() == nombre.lower():\n",
    "                raise ValueError(\"Ya existe una sala con ese nombre.\")\n",
    "        sid = self._nuevo_id(\"S\")\n",
    "        sala = Sala(id=sid, nombre=nombre, cupo=cupo)\n",
    "        self.salas[sid] = sala\n",
    "        self._guardar()\n",
    "        return sala\n",
    "\n",
    "    # -----------------------------\n",
    "    # Reservaciones\n",
    "    # -----------------------------\n",
    "\n",
    "    def _validar_fecha_reservacion(self, fecha_iso: str) -> None:\n",
    "        try:\n",
    "            f = datetime.strptime(fecha_iso, \"%Y-%m-%d\").date()\n",
    "        except ValueError:\n",
    "            raise ValueError(\"Formato de fecha inválido. Use YYYY-MM-DD.\")\n",
    "        if f < (date.today() + timedelta(days=2)):\n",
    "            raise ValueError(\"La reservación debe ser al menos 2 días después de hoy.\")\n",
    "\n",
    "    def salas_disponibles(self, fecha_iso: str, turno: str) -> List[Sala]:\n",
    "        self._validar_fecha_reservacion(fecha_iso)\n",
    "        if turno not in TURNOS:\n",
    "            raise ValueError(\"Turno inválido. Use M, V o N.\")\n",
    "        ocupadas = {r.id_sala for r in self.reservas.values() if r.fecha == fecha_iso and r.turno == turno}\n",
    "        return [s for s in self.salas.values() if s.id not in ocupadas]\n",
    "\n",
    "    def registrar_reserva(self, evento: str, id_cliente: str, id_sala: str, fecha_iso: str, turno: str) -> Reservacion:\n",
    "        evento = (evento or \"\").strip()\n",
    "        if not evento:\n",
    "            raise ValueError(\"El nombre del evento no puede estar vacío.\")\n",
    "        if id_cliente not in self.clientes:\n",
    "            raise ValueError(\"Cliente no encontrado.\")\n",
    "        if id_sala not in self.salas:\n",
    "            raise ValueError(\"Sala no encontrada.\")\n",
    "        self._validar_fecha_reservacion(fecha_iso)\n",
    "        if turno not in TURNOS:\n",
    "            raise ValueError(\"Turno inválido. Use M, V o N.\")\n",
    "        for r in self.reservas.values():\n",
    "            if r.id_sala == id_sala and r.fecha == fecha_iso and r.turno == turno:\n",
    "                raise ValueError(\"Ya existe una reservación en esa sala para esa fecha y turno.\")\n",
    "        rid = self._nuevo_id(\"R\")\n",
    "        reserva = Reservacion(folio=rid, evento=evento, id_cliente=id_cliente, id_sala=id_sala, fecha=fecha_iso, turno=turno)\n",
    "        self.reservas[rid] = reserva\n",
    "        self._guardar()\n",
    "        return reserva\n",
    "\n",
    "    # -----------------------------\n",
    "    # Edición y consulta\n",
    "    # -----------------------------\n",
    "\n",
    "    def reservas_en_rango(self, desde_iso: str, hasta_iso: str) -> List[Reservacion]:\n",
    "        d1 = datetime.strptime(desde_iso, \"%Y-%m-%d\").date()\n",
    "        d2 = datetime.strptime(hasta_iso, \"%Y-%m-%d\").date()\n",
    "        if d2 < d1:\n",
    "            raise ValueError(\"La fecha final no puede ser anterior a la inicial.\")\n",
    "        res = [r for r in self.reservas.values() if d1 <= datetime.strptime(r.fecha, \"%Y-%m-%d\").date() <= d2]\n",
    "        res.sort(key=lambda x: (x.fecha, x.folio))\n",
    "        return res\n",
    "\n",
    "    def editar_nombre_evento(self, folio: str, nuevo_nombre: str) -> Reservacion:\n",
    "        if folio not in self.reservas:\n",
    "            raise ValueError(\"Folio no encontrado.\")\n",
    "        nuevo_nombre = (nuevo_nombre or \"\").strip()\n",
    "        if not nuevo_nombre:\n",
    "            raise ValueError(\"El nuevo nombre no puede estar vacío.\")\n",
    "        self.reservas[folio].evento = nuevo_nombre\n",
    "        self._guardar()\n",
    "        return self.reservas[folio]\n",
    "\n",
    "    def reservas_por_fecha(self, fecha_iso: str) -> List[Reservacion]:\n",
    "        datetime.strptime(fecha_iso, \"%Y-%m-%d\")\n",
    "        res = [r for r in self.reservas.values() if r.fecha == fecha_iso]\n",
    "        res.sort(key=lambda x: (x.turno, x.folio))\n",
    "        return res\n",
    "\n",
    "# -----------------------------\n",
    "# Utilidades de interfaz\n",
    "# -----------------------------\n",
    "\n",
    "def linea(ancho: int = 80, char: str = \"-\") -> str:\n",
    "    return char * ancho\n",
    "\n",
    "def tabla(headers: List[str], filas: List[List[str]]) -> str:\n",
    "    if not filas:\n",
    "        return \"\"\n",
    "    col_widths = [max(len(str(h)), *(len(str(f[i])) for f in filas)) for i, h in enumerate(headers)]\n",
    "    def fmt_row(row): return \" | \".join(str(row[i]).ljust(col_widths[i]) for i in range(len(headers)))\n",
    "    out = [fmt_row(headers), \"-+-\".join(\"-\" * w for w in col_widths)]\n",
    "    for f in filas: out.append(fmt_row(f))\n",
    "    return \"\\n\".join(out)\n",
    "\n",
    "def input_no_vacio(prompt: str) -> str:\n",
    "    while True:\n",
    "        val = input(prompt).strip()\n",
    "        if val and not val.isspace(): \n",
    "            return val\n",
    "        print(\"⚠ No puede estar vacío ni contener solo espacios. Intente de nuevo.\")\n",
    "\n",
    "def input_entero(prompt: str, minimo: Optional[int] = None) -> int:\n",
    "    while True:\n",
    "        try:\n",
    "            v = int(input(prompt).strip())\n",
    "            if minimo is not None and v < minimo:\n",
    "                print(f\"⚠ Debe ser ≥ {minimo}.\"); continue\n",
    "            return v\n",
    "        except ValueError:\n",
    "            print(\"⚠ Ingrese un número válido.\")\n",
    "\n",
    "def input_fecha(prompt: str) -> str:\n",
    "    while True:\n",
    "        s = input(prompt).strip()\n",
    "        try:\n",
    "            datetime.strptime(s, \"%Y-%m-%d\")\n",
    "            return s\n",
    "        except ValueError:\n",
    "            print(\"⚠ Formato inválido. Use YYYY-MM-DD (ejemplo: 2025-12-25).\")\n",
    "\n",
    "def pausar():\n",
    "    input(\"\\n[Presione ENTER para continuar...]\")\n",
    "\n",
    "# -----------------------------\n",
    "# Opciones del menú\n",
    "# -----------------------------\n",
    "\n",
    "def opcion_registrar_reserva(repo: Repositorio):\n",
    "    print(linea())\n",
    "    print(\"REGISTRAR RESERVACIÓN DE SALA\")\n",
    "    print(linea())\n",
    "    \n",
    "    if not repo.clientes:\n",
    "        print(\"⚠ No hay clientes registrados. Registre un cliente primero.\")\n",
    "        pausar()\n",
    "        return\n",
    "    \n",
    "    if not repo.salas:\n",
    "        print(\"⚠ No hay salas registradas. Registre una sala primero.\")\n",
    "        pausar()\n",
    "        return\n",
    "    \n",
    "    # Mostrar listado de clientes ordenados alfabéticamente\n",
    "    clientes = repo.listar_clientes_ordenados()\n",
    "    print(\"\\nClientes registrados (ordenados alfabéticamente):\")\n",
    "    print(linea())\n",
    "    filas = [[c.id, f\"{c.apellidos}, {c.nombres}\"] for c in clientes]\n",
    "    print(tabla([\"Clave Cliente\", \"Apellidos, Nombres\"], filas))\n",
    "    print(linea())\n",
    "    \n",
    "    # Solicitar clave del cliente con opción de cancelar\n",
    "    while True:\n",
    "        id_cliente = input(\"\\nClave del cliente (o 'CANCELAR' para salir): \").strip()\n",
    "        if id_cliente.upper() == 'CANCELAR':\n",
    "            print(\"Operación cancelada.\")\n",
    "            pausar()\n",
    "            return\n",
    "        if id_cliente in repo.clientes:\n",
    "            break\n",
    "        print(\"\\n⚠ La clave seleccionada no existe.\")\n",
    "        print(\"\\nClientes registrados:\")\n",
    "        print(linea())\n",
    "        print(tabla([\"Clave Cliente\", \"Apellidos, Nombres\"], filas))\n",
    "        print(linea())\n",
    "    \n",
    "    # Solicitar fecha (debe ser al menos 2 días después)\n",
    "    print(f\"\\nFecha actual del sistema: {date.today().strftime('%Y-%m-%d')}\")\n",
    "    print(f\"La fecha debe ser al menos: {(date.today() + timedelta(days=2)).strftime('%Y-%m-%d')}\")\n",
    "    \n",
    "    while True:\n",
    "        fecha_iso = input_fecha(\"\\nFecha de reservación (YYYY-MM-DD): \")\n",
    "        try:\n",
    "            repo._validar_fecha_reservacion(fecha_iso)\n",
    "            break\n",
    "        except ValueError as e:\n",
    "            print(f\"⚠ {e}\")\n",
    "    \n",
    "    # Solicitar turno y mostrar salas disponibles\n",
    "    print(\"\\nSeleccione turno:\")\n",
    "    print(\"  M) Matutino\")\n",
    "    print(\"  V) Vespertino\")\n",
    "    print(\"  N) Nocturno\")\n",
    "    \n",
    "    while True:\n",
    "        turno = input(\"Turno [M/V/N]: \").strip().upper()\n",
    "        if turno in TURNOS:\n",
    "            break\n",
    "        print(\"⚠ Turno inválido. Use M, V o N.\")\n",
    "    \n",
    "    # Mostrar salas disponibles para la fecha y turno seleccionados\n",
    "    try:\n",
    "        salas_disp = repo.salas_disponibles(fecha_iso, turno)\n",
    "        \n",
    "        if not salas_disp:\n",
    "            print(f\"\\n⚠ No hay salas disponibles para el turno {TURNOS[turno]} el {fecha_iso}\")\n",
    "            pausar()\n",
    "            return\n",
    "        \n",
    "        print(f\"\\nSalas disponibles para {TURNOS[turno]} el {fecha_iso}:\")\n",
    "        print(linea())\n",
    "        filas_salas = [[s.id, s.nombre, str(s.cupo)] for s in salas_disp]\n",
    "        print(tabla([\"Clave Sala\", \"Nombre\", \"Cupo\"], filas_salas))\n",
    "        print(linea())\n",
    "        \n",
    "        while True:\n",
    "            id_sala = input(\"\\nClave de la sala: \").strip()\n",
    "            if id_sala in [s.id for s in salas_disp]:\n",
    "                break\n",
    "            print(\"⚠ Sala no disponible o no válida. Intente de nuevo.\")\n",
    "        \n",
    "        # Solicitar nombre del evento\n",
    "        evento = input_no_vacio(\"\\nNombre del evento: \")\n",
    "        \n",
    "        reserva = repo.registrar_reserva(evento, id_cliente, id_sala, fecha_iso, turno)\n",
    "        \n",
    "        print(\"\\n\" + linea())\n",
    "        print(\"✓ RESERVACIÓN REGISTRADA EXITOSAMENTE\")\n",
    "        print(linea())\n",
    "        print(f\"  Folio:   {reserva.folio}\")\n",
    "        print(f\"  Evento:  {reserva.evento}\")\n",
    "        print(f\"  Cliente: {repo.clientes[id_cliente].apellidos}, {repo.clientes[id_cliente].nombres}\")\n",
    "        print(f\"  Sala:    {repo.salas[id_sala].nombre}\")\n",
    "        print(f\"  Fecha:   {fecha_iso}\")\n",
    "        print(f\"  Turno:   {TURNOS[turno]}\")\n",
    "        print(linea())\n",
    "        \n",
    "    except ValueError as e:\n",
    "        print(f\"\\n✗ Error: {e}\")\n",
    "    pausar()\n",
    "\n",
    "def opcion_editar_evento(repo: Repositorio):\n",
    "    print(linea())\n",
    "    print(\"EDITAR NOMBRE DE EVENTO DE UNA RESERVACIÓN\")\n",
    "    print(linea())\n",
    "    \n",
    "    fecha_desde = input_fecha(\"Fecha inicial del rango (YYYY-MM-DD): \")\n",
    "    fecha_hasta = input_fecha(\"Fecha final del rango (YYYY-MM-DD): \")\n",
    "    \n",
    "    try:\n",
    "        reservas = repo.reservas_en_rango(fecha_desde, fecha_hasta)\n",
    "        \n",
    "        if not reservas:\n",
    "            print(f\"\\n⚠ No hay reservaciones en el rango {fecha_desde} a {fecha_hasta}\")\n",
    "            pausar()\n",
    "            return\n",
    "        \n",
    "        print(f\"\\nEventos registrados del {fecha_desde} al {fecha_hasta}:\")\n",
    "        print(linea())\n",
    "        filas = [[r.folio, r.evento, r.fecha] for r in reservas]\n",
    "        print(tabla([\"Folio\", \"Nombre del Evento\", \"Fecha\"], filas))\n",
    "        print(linea())\n",
    "        \n",
    "        while True:\n",
    "            folio = input(\"\\nFolio del evento a modificar (o 'CANCELAR' para salir): \").strip()\n",
    "            if folio.upper() == 'CANCELAR':\n",
    "                print(\"Operación de modificación cancelada.\")\n",
    "                pausar()\n",
    "                return\n",
    "            if folio in [r.folio for r in reservas]:\n",
    "                break\n",
    "            print(\"\\n⚠ El folio indicado no pertenece a este rango.\")\n",
    "            print(\"\\nEventos disponibles:\")\n",
    "            print(linea())\n",
    "            print(tabla([\"Folio\", \"Nombre del Evento\", \"Fecha\"], filas))\n",
    "            print(linea())\n",
    "        \n",
    "        nuevo_nombre = input_no_vacio(\"\\nNuevo nombre del evento: \")\n",
    "        repo.editar_nombre_evento(folio, nuevo_nombre)\n",
    "        \n",
    "        print(\"\\n\" + linea())\n",
    "        print(\"✓ Nombre del evento actualizado exitosamente\")\n",
    "        print(linea())\n",
    "        \n",
    "    except ValueError as e:\n",
    "        print(f\"\\n✗ Error: {e}\")\n",
    "    pausar()\n",
    "\n",
    "def opcion_consultar_por_fecha(repo: Repositorio):\n",
    "    print(linea())\n",
    "    print(\"CONSULTAR RESERVACIONES EXISTENTES PARA UNA FECHA ESPECÍFICA\")\n",
    "    print(linea())\n",
    "    fecha_iso = input_fecha(\"Fecha a consultar (YYYY-MM-DD): \")\n",
    "\n",
    "    try:\n",
    "        lista = repo.reservas_por_fecha(fecha_iso)\n",
    "    except Exception as e:\n",
    "        print(f\"✗ {e}\")\n",
    "        pausar()\n",
    "        return\n",
    "\n",
    "    if not lista:\n",
    "        print(f\"\\nNo hay reservaciones para la fecha {fecha_iso}.\")\n",
    "        pausar()\n",
    "        return\n",
    "\n",
    "    # Preparar datos para el reporte tabular\n",
    "    filas = []\n",
    "    for r in lista:\n",
    "        cli = repo.clientes.get(r.id_cliente)\n",
    "        sala = repo.salas.get(r.id_sala)\n",
    "        filas.append([\n",
    "            r.folio,\n",
    "            r.evento,\n",
    "            f\"{cli.apellidos}, {cli.nombres}\" if cli else r.id_cliente,\n",
    "            sala.nombre if sala else r.id_sala,\n",
    "            TURNOS.get(r.turno, r.turno),\n",
    "            str(sala.cupo if sala else \"\"),\n",
    "        ])\n",
    "    \n",
    "    print(f\"\\n╔{'═' * 78}╗\")\n",
    "    print(f\"║  RESERVACIONES DEL {fecha_iso}\".ljust(79) + \"║\")\n",
    "    print(f\"╚{'═' * 78}╝\")\n",
    "    print(tabla([\"Folio\", \"Evento\", \"Cliente\", \"Sala\", \"Turno\", \"Cupo\"], filas))\n",
    "\n",
    "    # Opción de exportar el reporte\n",
    "    print(\"\\n\" + linea())\n",
    "    print(\"¿Desea exportar el reporte?\")\n",
    "    print(\"  1) CSV\")\n",
    "    print(\"  2) JSON\")\n",
    "    print(\"  3) Excel (XLSX)\")\n",
    "    print(\"  0) No exportar\")\n",
    "    print(linea())\n",
    "    export_op = input(\"Seleccione una opción: \").strip()\n",
    "\n",
    "    if export_op in {\"1\", \"2\", \"3\"}:\n",
    "        nombre_base = f\"reporte_{fecha_iso.replace('-', '')}\"\n",
    "        try:\n",
    "            if export_op == \"1\":\n",
    "                with open(nombre_base + \".csv\", \"w\", newline=\"\", encoding=\"utf-8\") as f:\n",
    "                    writer = csv.writer(f)\n",
    "                    writer.writerow([\"Folio\", \"Evento\", \"Cliente\", \"Sala\", \"Turno\", \"Cupo\"])\n",
    "                    writer.writerows(filas)\n",
    "                print(f\"\\n✓ Reporte exportado como {nombre_base}.csv\")\n",
    "\n",
    "            elif export_op == \"2\":\n",
    "                data = [\n",
    "                    {\"Folio\": f[0], \"Evento\": f[1], \"Cliente\": f[2], \"Sala\": f[3], \"Turno\": f[4], \"Cupo\": f[5]}\n",
    "                    for f in filas\n",
    "                ]\n",
    "                with open(nombre_base + \".json\", \"w\", encoding=\"utf-8\") as f:\n",
    "                    json.dump(data, f, ensure_ascii=False, indent=2)\n",
    "                print(f\"\\n✓ Reporte exportado como {nombre_base}.json\")\n",
    "\n",
    "            elif export_op == \"3\":\n",
    "                try:\n",
    "                    from openpyxl import Workbook\n",
    "                    from openpyxl.styles import Font, Alignment, Border, Side\n",
    "                    \n",
    "                    wb = Workbook()\n",
    "                    ws = wb.active\n",
    "                    ws.title = \"Reservaciones\"\n",
    "                    \n",
    "                    # Título en la primera fila\n",
    "                    ws.merge_cells('A1:F1')\n",
    "                    titulo_cell = ws['A1']\n",
    "                    titulo_cell.value = f\"RESERVACIONES DEL {fecha_iso}\"\n",
    "                    titulo_cell.font = Font(bold=True, size=14)\n",
    "                    titulo_cell.alignment = Alignment(horizontal=\"center\")\n",
    "                    \n",
    "                    # Encabezados en la segunda fila\n",
    "                    headers = [\"Folio\", \"Evento\", \"Cliente\", \"Sala\", \"Turno\", \"Cupo\"]\n",
    "                    ws.append(headers)\n",
    "                    \n",
    "                    # Formato de encabezados: negritas y borde inferior grueso\n",
    "                    bold = Font(bold=True)\n",
    "                    border_grueso = Border(bottom=Side(border_style=\"thick\"))\n",
    "                    for col in range(1, len(headers) + 1):\n",
    "                        cell = ws.cell(row=2, column=col)\n",
    "                        cell.font = bold\n",
    "                        cell.border = border_grueso\n",
    "                        cell.alignment = Alignment(horizontal=\"center\")\n",
    "                    \n",
    "                    # Agregar datos\n",
    "                    for fila in filas:\n",
    "                        ws.append(fila)\n",
    "                    \n",
    "                    # Centrar datos en todas las columnas\n",
    "                    for row in ws.iter_rows(min_row=3, max_row=ws.max_row):\n",
    "                        for cell in row:\n",
    "                            cell.alignment = Alignment(horizontal=\"center\")\n",
    "                    \n",
    "                    # Ajustar ancho de columnas\n",
    "                    for col in ws.columns:\n",
    "                        max_len = max(len(str(c.value)) for c in col if c.value)\n",
    "                        ws.column_dimensions[col[0].column_letter].width = max_len + 2\n",
    "\n",
    "                    wb.save(nombre_base + \".xlsx\")\n",
    "                    print(f\"\\n✓ Reporte exportado como {nombre_base}.xlsx\")\n",
    "                    print(\"   (Con título y encabezados en negritas, bordes gruesos y datos centrados)\")\n",
    "                except ImportError:\n",
    "                    print(\"\\n✗ Error: El módulo 'openpyxl' no está instalado.\")\n",
    "                    print(\"   Instálelo con: pip install openpyxl\")\n",
    "\n",
    "        except Exception as e:\n",
    "            print(f\"\\n✗ Error al exportar: {e}\")\n",
    "    else:\n",
    "        print(\"\\nNo se exportó el reporte.\")\n",
    "    pausar()\n",
    "\n",
    "def opcion_registrar_cliente(repo: Repositorio):\n",
    "    print(linea())\n",
    "    print(\"REGISTRAR NUEVO CLIENTE\")\n",
    "    print(linea())\n",
    "    try:\n",
    "        nombres = input_no_vacio(\"Nombres: \")\n",
    "        apellidos = input_no_vacio(\"Apellidos: \")\n",
    "        cliente = repo.registrar_cliente(nombres, apellidos)\n",
    "        print(f\"\\n✓ Cliente registrado exitosamente\")"
   ]
  }
 ],
 "metadata": {
  "language_info": {
   "name": "python"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
