# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JyfN6OdjR18_1Q7z8JorspMXaNeF2KwN
"""

from __future__ import annotations
import json
import os
from dataclasses import dataclass, asdict
from datetime import date, datetime, timedelta
from typing import Dict, List, Optional, Tuple

DATA_FILE = "data_coworking.json"

TURNOS = {
    "M": "Mañana (09:00–13:00)",
    "T": "Tarde (14:00–18:00)",
    "N": "Noche (19:00–22:00)",
}

# -----------------------------
# Modelos de datos (VIctor Hugo)
# -----------------------------

@dataclass
class Cliente:
    id: str
    nombres: str
    apellidos: str

@dataclass
class Sala:
    id: str
    nombre: str
    cupo: int

@dataclass
class Reservacion:
    folio: str
    evento: str
    id_cliente: str
    id_sala: str
    fecha: str
    turno: str

# -----------------------------
# Capa de datos y utilidades
# -----------------------------

class Repositorio:
    def __init__(self, data_file: str = DATA_FILE) -> None:
        self.data_file = data_file
        self.clientes: Dict[str, Cliente] = {}
        self.salas: Dict[str, Sala] = {}
        self.reservas: Dict[str, Reservacion] = {}
        self._contadores = {"C": 0, "S": 0, "R": 0}
        self._cargar()

    def _nuevo_id(self, prefijo: str) -> str:
        self._contadores[prefijo] += 1
        return f"{prefijo}{self._contadores[prefijo]:04d}"

    def _cargar(self) -> None:
        if not os.path.exists(self.data_file):
            self._guardar()
            return
        try:
            with open(self.data_file, "r", encoding="utf-8") as f:
                data = json.load(f)
        except Exception:
            self._guardar()
            return

        for c in data.get("clientes", []):
            self.clientes[c["id"]] = Cliente(**c)
        for s in data.get("salas", []):
            self.salas[s["id"]] = Sala(**s)
        for r in data.get("reservas", []):
            self.reservas[r["folio"]] = Reservacion(**r)

        self._contadores = data.get("contadores", {"C": 0, "S": 0, "R": 0})

    def _guardar(self) -> None:
        data = {
            "clientes": [asdict(c) for c in self.clientes.values()],
            "salas": [asdict(s) for s in self.salas.values()],
            "reservas": [asdict(r) for r in self.reservas.values()],
            "contadores": self._contadores,
        }
        with open(self.data_file, "w", encoding="utf-8") as f:
            json.dump(data, f, ensure_ascii=False, indent=2)

    # -----------------------------
    # (Christopher de Jesus) Gestión de clientes
    # -----------------------------

    def registrar_cliente(self, nombres: str, apellidos: str) -> Cliente:
        nombres = nombres.strip()
        apellidos = apellidos.strip()
        if not nombres or not apellidos:
            raise ValueError("Nombres y apellidos no pueden estar vacíos.")

        for c in self.clientes.values():
            if c.nombres.lower() == nombres.lower() and c.apellidos.lower() == apellidos.lower():
                raise ValueError("El cliente ya existe.")

        cid = self._nuevo_id("C")
        cliente = Cliente(id=cid, nombres=nombres, apellidos=apellidos)
        self.clientes[cid] = cliente
        self._guardar()
        return cliente

    def listar_clientes_ordenados(self) -> List[Cliente]:
        return sorted(self.clientes.values(), key=lambda c: (c.apellidos.lower(), c.nombres.lower()))

    # -----------------------------
    # (Christopher de Jesus) Gestión de salas
    # -----------------------------

    def registrar_sala(self, nombre: str, cupo: int) -> Sala:
        nombre = nombre.strip()
        if not nombre:
            raise ValueError("El nombre de la sala no puede estar vacío.")
        if cupo <= 0:
            raise ValueError("El cupo debe ser mayor que 0.")

        for s in self.salas.values():
            if s.nombre.lower() == nombre.lower():
                raise ValueError("Ya existe una sala con ese nombre.")

        sid = self._nuevo_id("S")
        sala = Sala(id=sid, nombre=nombre, cupo=cupo)
        self.salas[sid] = sala
        self._guardar()
        return sala

    # -----------------------------
    # (Angel Isaac) Disponibilidad y reservas
    # -----------------------------

    def _validar_fecha_reservacion(self, fecha_iso: str) -> None:
        try:
            f = datetime.strptime(fecha_iso, "%Y-%m-%d").date()
        except ValueError:
            raise ValueError("Formato de fecha inválido. Use YYYY-MM-DD.")

        if f < (date.today() + timedelta(days=2)):
            raise ValueError("La reservación debe ser al menos 2 días después de hoy.")

    def salas_disponibles(self, fecha_iso: str, turno: str) -> List[Sala]:
        self._validar_fecha_reservacion(fecha_iso)
        if turno not in TURNOS:
            raise ValueError("Turno inválido. Use M, T o N.")

        ocupadas = {r.id_sala for r in self.reservas.values() if r.fecha == fecha_iso and r.turno == turno}
        return [s for s in self.salas.values() if s.id not in ocupadas]

    def registrar_reserva(self, evento: str, id_cliente: str, id_sala: str, fecha_iso: str, turno: str) -> Reservacion:
        evento = (evento or "").strip()
        if not evento:
            raise ValueError("El nombre del evento no puede estar vacío.")

        if id_cliente not in self.clientes:
            raise ValueError("Cliente no encontrado.")
        if id_sala not in self.salas:
            raise ValueError("Sala no encontrada.")
        self._validar_fecha_reservacion(fecha_iso)
        if turno not in TURNOS:
            raise ValueError("Turno inválido. Use M, T o N.")

        for r in self.reservas.values():
            if r.id_sala == id_sala and r.fecha == fecha_iso and r.turno == turno:
                raise ValueError("Ya existe una reservación en esa sala para la fecha y turno seleccionados.")

        rid = self._nuevo_id("R")
        reserva = Reservacion(
            folio=rid,
            evento=evento,
            id_cliente=id_cliente,
            id_sala=id_sala,
            fecha=fecha_iso,
            turno=turno
        )
        self.reservas[rid] = reserva
        self._guardar()
        return reserva

    # -----------------------------
    # (David Oswaldo) Edición por rango de fechas
    # -----------------------------

    def reservas_en_rango(self, desde_iso: str, hasta_iso: str) -> List[Reservacion]:
        try:
            d1 = datetime.strptime(desde_iso, "%Y-%m-%d").date()
            d2 = datetime.strptime(hasta_iso, "%Y-%m-%d").date()
        except ValueError:
            raise ValueError("Formato de fecha inválido. Use YYYY-MM-DD.")
        if d2 < d1:
            raise ValueError("La fecha final no puede ser anterior a la inicial.")

        res = []
        for r in self.reservas.values():
            rf = datetime.strptime(r.fecha, "%Y-%m-%d").date()
            if d1 <= rf <= d2:
                res.append(r)
        res.sort(key=lambda x: (x.fecha, x.folio))
        return res

    def editar_nombre_evento(self, folio: str, nuevo_nombre: str) -> Reservacion:
        if folio not in self.reservas:
            raise ValueError("Folio no encontrado.")
        nuevo_nombre = (nuevo_nombre or "").strip()
        if not nuevo_nombre:
            raise ValueError("El nuevo nombre del evento no puede estar vacío.")
        self.reservas[folio].evento = nuevo_nombre
        self._guardar()
        return self.reservas[folio]

    # -----------------------------
    # (David Oswaldo) Consultas y formato
    # -----------------------------

    def reservas_por_fecha(self, fecha_iso: str) -> List[Reservacion]:
        try:
            datetime.strptime(fecha_iso, "%Y-%m-%d")
        except ValueError:
            raise ValueError("Formato de fecha inválido. Use YYYY-MM-DD.")

        res = [r for r in self.reservas.values() if r.fecha == fecha_iso]
        res.sort(key=lambda x: (x.turno, x.folio))
        return res

# -----------------------------
# Utilidades de UI (Andrik Sebastian)
# -----------------------------

def _linea(ancho: int = 80, char: str = "-") -> str:
    return char * ancho

def tabla(headers: List[str], filas: List[List[str]]) -> str:
    cols = len(headers)
    col_widths = [len(h) for h in headers]
    for fila in filas:
        for i in range(cols):
            col_widths[i] = max(col_widths[i], len(str(fila[i])))

    def fmt_row(row: List[str]) -> str:
        return " | ".join(str(row[i]).ljust(col_widths[i]) for i in range(cols))

    out = []
    out.append(fmt_row(headers))
    out.append("-+-".join("-" * w for w in col_widths))
    for f in filas:
        out.append(fmt_row(f))
    return "\n".join(out)

# -----------------------------
# Menú de aplicación (Andrik Sebastian)
# -----------------------------

def input_no_vacio(prompt: str) -> str:
    while True:
        val = input(prompt).strip()
        if val:
            return val
        print(" No puede estar vacío. Intente de nuevo.")

def input_entero(prompt: str, minimo: Optional[int] = None) -> int:
    while True:
        try:
            v = int(input(prompt).strip())
            if minimo is not None and v < minimo:
                print(f" Debe ser un entero ≥ {minimo}.")
                continue
            return v
        except ValueError:
            print(" Ingrese un número entero.")

def input_fecha(prompt: str) -> str:
    while True:
        s = input(prompt).strip()
        try:
            datetime.strptime(s, "%Y-%m-%d")
            return s
        except ValueError:
            print(" Formato inválido. Use YYYY-MM-DD.")

def seleccionar_turno() -> str:
    print("Seleccione turno:")
    for k, v in TURNOS.items():
        print(f"  {k}) {v}")
    while True:
        t = input("Turno [M/T/N]: ").strip().upper()
        if t in TURNOS:
            return t
        print(" Turno inválido. Use M, T o N.")

def pausar():
    input("\nPresione ENTER para continuar...")

def opcion_registrar_cliente(repo: Repositorio):
    print(_linea())
    print("REGISTRAR CLIENTE")
    print(_linea())
    nombres = input_no_vacio("Nombres: ")
    apellidos = input_no_vacio("Apellidos: ")
    try:
        c = repo.registrar_cliente(nombres, apellidos)
        print(f" Cliente registrado: {c.id} - {c.apellidos}, {c.nombres}")
    except Exception as e:
        print(f" {e}")
    pausar()

def opcion_registrar_sala(repo: Repositorio):
    print(_linea())
    print("REGISTRAR SALA")
    print(_linea())
    nombre = input_no_vacio("Nombre de la sala: ")
    cupo = input_entero("Cupo (entero > 0): ", minimo=1)
    try:
        s = repo.registrar_sala(nombre, cupo)
        print(f" Sala registrada: {s.id} - {s.nombre} (cupo {s.cupo})")
    except Exception as e:
        print(f" {e}")
    pausar()

def opcion_listar_clientes(repo: Repositorio):
    print(_linea())
    print("LISTA DE CLIENTES (Apellidos, Nombres)")
    print(_linea())
    clientes = repo.listar_clientes_ordenados()
    if not clientes:
        print("No hay clientes registrados.")
    else:
        filas = [[c.id, c.apellidos + ", " + c.nombres] for c in clientes]
        print(tabla(["ID", "Cliente"], filas))
    pausar()

def opcion_registrar_reserva(repo: Repositorio):
    print(_linea())
    print("REGISTRAR RESERVACIÓN")
    print(_linea())
    if not repo.clientes or not repo.salas:
        print(" Debe haber al menos 1 cliente y 1 sala registrados.")
        pausar()
        return

    evento = input_no_vacio("Nombre del evento: ")
    clientes = repo.listar_clientes_ordenados()
    print("\nClientes:")
    print(tabla(["ID", "Cliente"], [[c.id, f"{c.apellidos}, {c.nombres}"] for c in clientes]))
    id_cliente = input_no_vacio("Ingrese ID del cliente: ").upper()
    if id_cliente not in repo.clientes:
        print(" Cliente no encontrado.")
        pausar()
        return

    fecha_iso = input_fecha("Fecha del evento (YYYY-MM-DD): ")
    turno = seleccionar_turno()

    try:
        disponibles = repo.salas_disponibles(fecha_iso, turno)
    except Exception as e:
        print(f" {e}")
        pausar()
        return

    if not disponibles:
        print(" No hay salas disponibles para esa fecha y turno.")
        pausar()
        return

    print("\nSalas disponibles:")
    print(tabla(["ID", "Sala", "Cupo"], [[s.id, s.nombre, str(s.cupo)] for s in disponibles]))
    id_sala = input_no_vacio("Ingrese ID de la sala: ").upper()
    if id_sala not in {s.id for s in disponibles}:
        print(" La sala no está en la lista de disponibles.")
        pausar()
        return

    try:
        r = repo.registrar_reserva(evento, id_cliente, id_sala, fecha_iso, turno)
        print(f" Reservación creada. Folio: {r.folio}")
    except Exception as e:
        print(f" {e}")
    pausar()

def opcion_editar_evento(repo: Repositorio):
    print(_linea())
    print("EDITAR NOMBRE DE EVENTO (por rango de fechas)")
    print(_linea())
    if not repo.reservas:
        print("No hay reservaciones registradas.")
        pausar()
        return

    desde = input_fecha("Fecha inicial (YYYY-MM-DD): ")
    hasta = input_fecha("Fecha final   (YYYY-MM-DD): ")

    try:
        lista = repo.reservas_en_rango(desde, hasta)
    except Exception as e:
        print(f" {e}")
        pausar()
        return

    if not lista:
        print("No hay reservaciones en el rango indicado.")
        pausar()
        return

    filas = []
    for r in lista:
        cli = repo.clientes.get(r.id_cliente)
        sala = repo.salas.get(r.id_sala)
        filas.append([
            r.folio,
            r.evento,
            f"{cli.apellidos}, {cli.nombres}" if cli else r.id_cliente,
            sala.nombre if sala else r.id_sala,
            r.fecha,
            TURNOS.get(r.turno, r.turno),
        ])
    print("\nReservaciones en el rango:")
    print(tabla(["Folio", "Evento", "Cliente", "Sala", "Fecha", "Turno"], filas))

    folio = input_no_vacio("\nIngrese el Folio a editar (o escriba 'CANCELAR' para salir): ").upper()
    if folio == "CANCELAR":
        print("Operación cancelada.")
        pausar()
        return

    if folio not in {r.folio for r in lista}:
        print(" Folio no válido para el rango mostrado.")
        pausar()
        return

    nuevo = input_no_vacio("Nuevo nombre de evento: ")
    try:
        r = repo.editar_nombre_evento(folio, nuevo)
        print(f" Evento actualizado. Folio {r.folio} → '{r.evento}'")
    except Exception as e:
        print(f" {e}")
    pausar()

def opcion_consultar_por_fecha(repo: Repositorio):
    print(_linea())
    print("CONSULTAR RESERVACIONES POR FECHA")
    print(_linea())
    fecha_iso = input_fecha("Fecha a consultar (YYYY-MM-DD): ")

    try:
        lista = repo.reservas_por_fecha(fecha_iso)
    except Exception as e:
        print(f" {e}")
        pausar()
        return

    if not lista:
        print("No hay reservaciones para esa fecha.")
        pausar()
        return

    filas = []
    for r in lista:
        cli = repo.clientes.get(r.id_cliente)
        sala = repo.salas.get(r.id_sala)
        filas.append([
            r.folio,
            r.evento,
            f"{cli.apellidos}, {cli.nombres}" if cli else r.id_cliente,
            sala.nombre if sala else r.id_sala,
            TURNOS.get(r.turno, r.turno),
            str(sala.cupo if sala else ""),
        ])
    print("\nReservaciones del día:")
    print(tabla(["Folio", "Evento", "Cliente", "Sala", "Turno", "Cupo"], filas))
    pausar()

def menu():
    repo = Repositorio()

    opciones = {
        "1": ("Registrar cliente", opcion_registrar_cliente),
        "2": ("Registrar sala", opcion_registrar_sala),
        "3": ("Listar clientes (A-Z)", opcion_listar_clientes),
        "4": ("Registrar reservación", opcion_registrar_reserva),
        "5": ("Editar nombre de evento (rango fechas)", opcion_editar_evento),
        "6": ("Consultar reservaciones por fecha", opcion_consultar_por_fecha),
        "0": ("Salir", None),
    }

    while True:
        os.system("cls" if os.name == "nt" else "clear")
        print("=== Sistema de Reservaciones Coworking ===")
        print(_linea())
        for k in sorted(opciones.keys()):
            print(f"{k}) {opciones[k][0]}")
        print(_linea())
        op = input("Seleccione una opción: ").strip()

        if op == "0":
            print("¡Hasta luego!")
            break
        elif op in opciones:
            _, fn = opciones[op]
            if fn:
                os.system("cls" if os.name == "nt" else "clear")
                fn(repo)
        else:
            print("Opción inválida.")
            pausar()

if __name__ == "__main__":
    menu()